import logging
import sqlite3
import requests
from io import BytesIO
from telegram import Update, InputFile
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes
from aiohttp import web
import asyncio
import nest_asyncio
from pyngrok import ngrok

# Logging setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

BOT_TOKEN = "7858281120:AAFqSrFzk0L9dwe7JwwyZPOcdvXmOcLK3Ao"
OWNER_ID = 8022012230
Converso_API_KEY = "mg-tg-1"
System_Server_URL = "https://system.stylefort.store"

# Database
conn = sqlite3.connect("config.db")
cursor = conn.cursor()
cursor.execute("""
CREATE TABLE IF NOT EXISTS config (
    key TEXT PRIMARY KEY,
    value TEXT
)
""")
conn.commit()

def get_model_id():
    cursor.execute("SELECT value FROM config WHERE key = 'model_id'")
    row = cursor.fetchone()
    return row[0] if row else "provider-1/FLUX.1.1-pro"

def escape_md(text: str) -> str:
    for ch in '_*[]`()~>#+=-|{}.!':
        text = text.replace(ch, f'\\{ch}')
    return text

# --- Telegram Bot Commands ---
async def set_model(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != OWNER_ID:
        await update.message.reply_text("⛔ You are not authorized.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /setmodel <MODEL_ID>")
        return
    model_id = context.args[0]
    cursor.execute("REPLACE INTO config (key, value) VALUES ('model_id', ?)", (model_id,))
    conn.commit()
    await update.message.reply_text(f"✅ Model ID set to `{model_id}`")

async def get_model(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != OWNER_ID:
        await update.message.reply_text("⛔ You are not authorized.")
        return
    model_id = get_model_id()
    await update.message.reply_text(f"📌 Current Model ID: `{model_id}`")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "👋 Welcome! Use `/gen <prompt>` or send API requests to generate images.")

# --- Shared image sending logic for both command and API ---
async def send_generated_image(
    bot_or_update, chat_id, prompt, image_url, time_spent, username=None, user_id=None, reply_to_message_id=None, is_api=False
):
    prompt_words = prompt.split()
    if len(prompt_words) > 20:
        short_prompt = " ".join(prompt_words[:20]) + "..."
    else:
        short_prompt = prompt
    if is_api:
        # API: no username/user_id context, just show prompt and time
        caption = (
            f"✨ Generation Complete\n"
            f"👤 Generated By: [\u200B{escape_md(username)}]({user_id})\n"
            f"🖼️ Prompt: `{escape_md(short_prompt)}`\n"
            f"🕒 Generation Time: `{round(time_spent, 2)} seconds`\n\n"
            f"🤖 Bot created by [Muhammad Gohar](tg://user?id={OWNER_ID})\n"
            f"*Powered by [Converso AI](https://conversoai.stylefort.store)*"
        )
    else:
        # Command: show user context
        caption = (
            f"✨ Generation Complete\n"
            f"👤 Generated By: [\u200B{escape_md(username)}](tg://user?id={user_id})\n"
            f"🖼️ Prompt: `{escape_md(short_prompt)}`\n"
            f"🕒 Generation Time: `{round(time_spent, 2)} seconds`\n\n"
            f"🤖 Bot created by [Muhammad Gohar](tg://user?id={OWNER_ID})\n"
            f"*Powered by [Converso AI](https://conversoai.stylefort.store)*"
        )
    img_data = requests.get(image_url).content
    image_io = BytesIO(img_data)
    image_io.name = "spoiler_image.jpg"
    if is_api:
        await bot_or_update.send_photo(
            chat_id=chat_id,
            photo=InputFile(image_io),
            caption=caption,
            parse_mode="MarkdownV2",
            has_spoiler=True,
            reply_to_message_id=reply_to_message_id
        )
    else:
        await bot_or_update.message.reply_photo(
            photo=InputFile(image_io),
            caption=caption,
            parse_mode="MarkdownV2",
            has_spoiler=True,
            reply_to_message_id=reply_to_message_id
        )

# --- Telegram Bot Commands (continued) ---
async def generate_image(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.args:
        await update.message.reply_text(
            "⚡ *Provide a prompt.*\n_Example:_ `/gen A cyberpunk dragon at night`",
            parse_mode="Markdown",
            reply_to_message_id=update.message.message_id if update.message else None
        )
        return
    prompt = " ".join(context.args)
    if "m=un" in prompt:
        model_id = "un"
        prompt = prompt.replace("m=un", "").strip()
    else:
        model_id = get_model_id()
    username = update.effective_user.first_name or "User"
    user_id = update.effective_user.id
    from datetime import datetime
    start_time = datetime.now()
    await update.message.reply_text(
        f"🎨 Generating image for: `{escape_md(prompt)}`",
        parse_mode="MarkdownV2",
        reply_to_message_id=update.message.message_id if update.message else None
    )
    url = f"{System_Server_URL}/telegram/images/generations"
    headers = {
        "Authorization": f"Bearer {Converso_API_KEY}",
        "Content-Type": "application/json"
    }
    data = {
        "model": model_id,
        "prompt": prompt
    }
    try:
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        print(result)
        image_url = result.get("url")
        if not image_url:
            await update.message.reply_text(
                "❌ *No image generated.* Try a more detailed prompt.",
                parse_mode="Markdown",
                reply_to_message_id=update.message.message_id if update.message else None
            )
            return
        time_spent = (datetime.now() - start_time).total_seconds()
        await send_generated_image(
            update, update.effective_chat.id, prompt, image_url, time_spent,
            username=username, user_id=user_id, reply_to_message_id=update.message.message_id, is_api=False
        )
    except requests.exceptions.RequestException as e:
        logging.error(f"API request failed: {e}")
        await update.message.reply_text(
            "❌ *Failed to generate image.* Please try again later.",
            parse_mode="Markdown",
            reply_to_message_id=update.message.message_id if update.message else None
        )
    except (KeyError, IndexError):
        logging.error(f"Unexpected API response: {response.text}")
        await update.message.reply_text(
            "⚠️ *Unexpected API response.*",
            parse_mode="Markdown",
            reply_to_message_id=update.message.message_id if update.message else None
        )

async def api_key(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = f"{update.effective_user.id}@telegram.org"
    user_name = f"{update.effective_user.first_name} {update.effective_user.last_name or ''}".strip()
    url = f"{System_Server_URL}/telegram/get/apiKey"
    res = requests.post(url, json={
        "user_id": user_id,
        "user_name": user_name
    }, headers={
        "Authorization": f"Bearer {Converso_API_KEY}",
        "Content-Type": "application/json"
    })
    if res.status_code == 200:
        data = res.json()
        api_key = data["api_key"]
        await update.message.reply_text(f"{data['message']}\n\n`{api_key}`", parse_mode="Markdown")
    else:
        await update.message.reply_text("⚠️ Something went wrong. Please try again later.")

# --- Internal HTTP Server for API ---
async def generate_and_post_image(bot, chat_id, prompt, server_url, api_key, model_id, reply_to_message_id=None, username=None, user_id=None):
    from datetime import datetime
    start_time = datetime.now()
    # Only include reply_to_message_id if it is a valid integer and > 0
    send_message_kwargs = {
        'chat_id': chat_id,
        'text': f"🎨 Generating image for: `{escape_md(prompt)}`",
        'parse_mode': "MarkdownV2"
    }
    if isinstance(reply_to_message_id, int) and reply_to_message_id > 0:
        send_message_kwargs['reply_to_message_id'] = reply_to_message_id
    await bot.send_message(**send_message_kwargs)
    url = f"{server_url}/telegram/images/generations"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    data = {
        "model": model_id,
        "prompt": prompt
    }
    try:
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        image_url = result.get("url")
        if not image_url:
            error_kwargs = {
                'chat_id': chat_id,
                'text': "❌ *No image generated.* Try a more detailed prompt.",
                'parse_mode': "Markdown"
            }
            if isinstance(reply_to_message_id, int) and reply_to_message_id > 0:
                error_kwargs['reply_to_message_id'] = reply_to_message_id
            await bot.send_message(**error_kwargs)
            return
        time_spent = (datetime.now() - start_time).total_seconds()
        await send_generated_image(
            bot, chat_id, prompt, image_url, time_spent,
            username=username, user_id=user_id, reply_to_message_id=reply_to_message_id if isinstance(reply_to_message_id, int) and reply_to_message_id > 0 else None, is_api=True
        )
    except Exception as e:
        logging.error(f"Image generation failed: {e}")
        error_kwargs = {
            'chat_id': chat_id,
            'text': "❌ *Failed to generate image.* Please try again later.",
            'parse_mode': "Markdown"
        }
        if isinstance(reply_to_message_id, int) and reply_to_message_id > 0:
            error_kwargs['reply_to_message_id'] = reply_to_message_id
        await bot.send_message(**error_kwargs)

async def handle_generate(request):
    data = await request.json()
    prompt = data.get('prompt')
    chat_id = data.get('chat_id')
    message_id = data.get('message_id')
    username = data.get('username')
    userid = data.get('user_id')
    print(f"Received request to generate image: chat_id={chat_id}, message_id={message_id}, username={username}, user_id={userid}")
    if not prompt or not chat_id:
        return web.json_response({'status': 'error', 'reason': 'missing data'}, status=400)
    await generate_and_post_image(request.app['bot'], chat_id, prompt, System_Server_URL, Converso_API_KEY, get_model_id(), reply_to_message_id=message_id, username=username, user_id=userid)
    return web.json_response({'status': 'ok'})

async def start_web_server(bot):
    app = web.Application()
    app['bot'] = bot
    app.router.add_post('/generate', handle_generate)
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', 8080)
    await site.start()
    public_url = ngrok.connect(8080, "http")
    logging.info(f"🌐 Public URL for /generate: {public_url}/generate")
    print(f"🌐 Public URL for /generate: {public_url}/generate")
    import re
    def extract_ngrok_url(text):
        """
        Extracts the first Ngrok URL from the given text.
        If no Ngrok URL is found, returns None.
        """
        match = re.search(r'https://[^\s"]+\.ngrok-free\.app', text)
        if match:
            return match.group(0)
        return None
    # Extract the public URL from the ngrok output
    public_url = extract_ngrok_url(str(public_url))
    requests.post(
        f"{System_Server_URL}/telegram/webhook",
        json={"url": f"{public_url}/generate"},
        headers={
            "Authorization": f"Bearer {Converso_API_KEY}"
        }
    )

# --- Main Entrypoint ---
async def main():
    app = ApplicationBuilder().token(BOT_TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("setmodel", set_model))
    app.add_handler(CommandHandler("getmodel", get_model))
    app.add_handler(CommandHandler("gen", generate_image))
    app.add_handler(CommandHandler("apiKey", api_key))
    asyncio.create_task(start_web_server(app.bot))
    await app.run_polling()
    

if __name__ == "__main__":
    nest_asyncio.apply()
    asyncio.run(main())
